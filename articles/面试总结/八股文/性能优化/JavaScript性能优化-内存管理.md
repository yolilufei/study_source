## 内存管理
什么是内存： 
**可读写的最小单元，表示一片可操作的空间。** 

什么是内存管理： 
**通过人为的操作申请内存、使用内存以及释放内存** 

那为什么需要内存管理： 
- **内存是有限的，当 js 在运行时，使用的内存过多，也就相当于浏览器占用内存过多，计算机运行速度会越来越慢。相应的浏览器运行就会出现卡顿。**

## 垃圾回收

## GC 算法
简介：GC 是一种机制，查找垃圾回收释放内存。可以通过相应的算法加快垃圾处理工作。
由于JS是单线程运行的，GC 回收和 js 运行是**互斥**的，如果GC的工作时间过长，就回阻塞 JS 的运行。因此，出现了各种各样的算法提高 GC 效率。 
常见的 GC 算法： 
- 引用计数
- 标记清除
- 标记整理
- 分代回收

## GC 算法实现原理
 ### 引用计数 
 将对象被引用次数保存起来，当引用次数变为 0 时将其释放。
 另外，引用计数法会对每个对象维护一个计数器。
 举例： 
 ```javascript
 // window
 function getUser() {
   const user = {
     name: 'guoshi',
     gender: 'male',
   }
   return user;
 }

 getUser();
 ```
getUser 中有一个 user 变量，它引用了 `{name: 'guoshi', gender: 'male'}` 这个对象。这个对象的计数值 + 1  = 1。当执行完 getUser 方法后，函数内的变量不再使用，user 引用的对象计数值 - 1 = 0。内存会立即释放该对象。 
再来看一个例子 
```javascript
// window
const user = {
     name: 'guoshi',
     gender: 'male',
}
 function getUser() {
   const name = 'lufei';
   user.name = name;
   return user;
 }

 getUser();

 ```
 当执行完 getUser 方法后，name 变量不再使用，计数值为0，被内存回收。而user对象挂载在 window 对象上，计数值为1，所以不会被内存回收。

 引用计数的优点： 
 - 对象不再使用被立即回收
 - 回收效率高。引用计数算法和其他的回收算法不同，不需要设定特定的回收时间，当有对象的计数变为0时立即执行回收操作。相当于回收操作平均到了每个对象上，因此效率会高。 
 引用计数的缺点：
 - 额外的空间和时间开销。由于引用计数算法会对每个对象维护一份引用计数器，增加了额外的内存空间。同时由于计数的加减操作，又增加了时间开销。
 - 无法回收循环引用的对象（致命缺陷）
 举例：
 ```javascript
function getUser() {
  const user1 = { r: user2};
  const user2 = { r: user1};
}
getUser();
 ```
 user1 的对象属性 r 引用了 user2 对象。user2 的对象属性 r 又引用了 user1 对象，当 getUser 执行完毕后，由于 user1 和 user2 存在互相引用，各自的计数值都为 1，无法成为0。user1 和 user2 也就形成了**孤岛**，垃圾回收机制永远无法回收这片区域。

### 标记清除
先解释下什么是可达对象。 

可达对象：从根结点出发，能够访问到的对象。无论寻找方式多麻烦，只要能找到，就算是可达对象。 
标记清除算法的原理就是标记所有可达对象为 活动对象。之后再遍历所有对象，将没有标记的对象清除掉。同时把已标记的对象清除标记，方便下一次的GC回收。
![标记清除图解](imgs/biaoji.png) 

标记清除的优点： 
- 解决循环引用问题

标记清除的缺点：
- 造成内存碎片空间, 不方便后续大对象的存储。

### 标记整理（减少碎片化空间）
标记整理算法分为 **标记** 和 **整理** 两部分。标记部分和标记清除算法是一致的，整理部分会在清除对象前将可达对象排列整理，使空间变为可连续的。

## V8引擎的垃圾回收

## Performance工具

## 实战